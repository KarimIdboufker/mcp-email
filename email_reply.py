import asyncio
import os
import io
from mcp.server.models import InitializationOptions
from mcp import types
from mcp.server import NotificationOptions, Server
import mcp.server.stdio
import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
import imaplib
import email
import time
import json


EMAIL_USER =  os.environ['EMAIL_USER']
EMAIL_PASSWORD = os.environ['EMAIL_APP_PASSWORD']
IMAP_SERVER = 'imap.gmail.com'
IMAP_PORT = 993
    

async def fetch_n_emails(n=5): 
    """takes email address and access code and returns n unread emails
        connects to gmail via IMAP
    """
    with imaplib.IMAP4_SSL(IMAP_SERVER, IMAP_PORT) as mail:
        mail.login(EMAIL_USER, EMAIL_PASSWORD)
        mail.select("inbox")
        # find unread email
        status, data = mail.search(None, "ALL")
        unread_msg = data[0].split()
        recent_msg = unread_msg[-n:] if len(unread_msg) >=n else unread_msg
        emails=[]
        for k in recent_msg:
            status, msg_data = mail.fetch(k, "(RFC822)")
            msg = email.message_from_bytes(msg_data[0][1])
            from_ = msg["From"]
            subject = msg["Subject"]
            if msg.is_multipart():
                for part in msg.walk():
                    if part.get_content_type() == 'text/plain':
                        body = part.get_payload(decode=True).decode('utf-8', errors='ignore')
                        break
            else:
                body = msg.get_payload(decode=True).decode("utf-8", errors ="ignore")
            emails.append(
                {
                "id": k.decode(),
                "from": from_,
                "subject": subject,
                "body": body
                }
            )
            
        return emails


async def draft_reply(initial_msg, reply):
    """
    takes the n emails fetched by fetch_unread function and draft replies for approval to send
    """
    msg = MIMEText(reply)
    msg["Subject"] = "Re:" + initial_msg.get("subject", "")
    msg["From"] = EMAIL_USER
    msg["To"] = initial_msg.get("from", "")
    
    with imaplib.IMAP4_SSL(IMAP_SERVER, IMAP_PORT) as mail:
        mail.login(EMAIL_USER, EMAIL_PASSWORD)
        mail.select("[Gmail]/Drafts")
        mail.append(
            "[Gmail]/Drafts",
            "",
            imaplib.Time2Internaldate(time.time()),
            msg.as_bytes(),
        )
    
    return "Draft Reply Saved"

#----------------------------------
# MCP SERVER setup
#----------------------------------

server = Server("email-reply-server")

@server.list_tools()
async def handle_list_tools() -> list[types.Tool]:
    return[
        types.Tool(
            name="fetch_n_emails",
            description = " fetch n unread emails from Gmail via IMAP",
            inputSchema = {
                "type": "object",
                "properties": {
                    "n": {
                        "type": "integer",
                        "description": "Maximum number of unread emails to fetch",
                        "maximum": 50,
                    }
                },
                "required": [],
            }
        ),
        types.Tool(
            name="draft_reply",
            description = "drafts reply for the n fetched emails by tool fetch_n_emails in Gmail",
            inputSchema = {
                "type": "object",
                "properties": {
                     "id": {
                        "type": "string",
                        "description": "IMAP sequence id of the original email",
                    },
                    "from": {
                        "type": "string",
                        "description": "Original sender address",
                    },
                    "subject": {
                        "type": "string",
                        "description": "Original email subject",
                    },
                    "body": {
                        "type": "string",
                        "description": "Original email body",
                    },
                    "reply_body": {
                        "type": "string",
                        "description": "Reply body text generated by the client",
                    },
                },
                "required": ["id", "from", "subject", "body", "reply_body"],
            },
        ),
    ]

@server.call_tool()
async def handle_call_tool(name: str, arguments: dict) -> list[types.TextContent]:
    if name == "fetch_n_emails":
        n = int(arguments.get("n", 5))
        emails = await fetch_n_emails(n=n)
        return [
            types.TextContent(
                type="text",
                text=json.dumps(emails, ensure_ascii=False, indent=2)
            )
        ]
    if name == "draft_reply":
        initial_msg = {
            "from": arguments["from"],
            "subject": arguments["subject"],
            "body": arguments["body"]
        }
        reply_body = arguments["reply_body"]
        
        result = await draft_reply(initial_msg, reply_body)
        return [types.TextContent(type="text", text=result)]
    
    raise ValueError(f"Wrong tool: {name}")

async def main():
    async with mcp.server.stdio.stdio_server() as (read_stream, write_stream):
        await server.run(
            read_stream,
            write_stream,
            InitializationOptions(
                server_name="email-reply-server",
                server_version="1.0.0",
                capabilities=server.get_capabilities(
                    notification_options=NotificationOptions(),
                    experimental_capabilities={}
                ),    
            ),
        )
        
    

if __name__ == "__main__":
    asyncio.run(main())